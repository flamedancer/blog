---
layout: post 
title: 创建型 
categories: [design-pattern]
---
### 单例模式  ###
确保类只有一个实例，并提供该实例的全局访问

我的理解:从这几个方面考虑
1. 单例类只有一个实例。不管用户用什么方式，尽量保证单例只有一个实例
2. 线程安全。如何避免因为线程并发同时执行了初始化实例的代码,赵成两个线程有两个实例
3. 延迟初始化。一般来说(如果初始化不需要很费时),只有当要用到实例的时候，才去创建单例

### 简单工厂  ###
在创建一个对象时，不向客户暴露细节，并提供创建对象的接口

我的理解:
1. 用户不需要知道有哪些类，只需要提供代号，就可以得到想要的实例。不需要知道具体类的初始化方法等
2. 提供一个方法(类)，输入为 代号， 根据代号判断要实例化哪个类，实例化后把实例返回

### 工厂方法  ###
定义了一个创建对象的方法，由子类决定实例化哪个类。工厂方法把实例化操作推迟到子类

我的理解:
1. 一个对象被实例化后可能还不能直接使用，还要对它做额外操作
2. 可能有很多对象都需要这样。虽然对象不一样，但做的"额外操作"是一样的
3. 则可以创建一个父工厂类, 提供这个做"额外操作" 的方法和返回实例对象的接口
4. 子工厂类只需要实现各自的 "返回实例对象的接口"
5. 用户只需 实例化子工厂类后，可直接调用 "额外操作"

### 抽象工厂 ###
提供一个接口，用于创建相关的对象家族
抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。
从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

``` java 
public class AbstractProductA {
}
public class AbstractProductB {
}
public class ProductA1 extends AbstractProductA {
}
public class ProductA2 extends AbstractProductA {
}
public class ProductB1 extends AbstractProductB {
}
public class ProductB2 extends AbstractProductB {
}
public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}
public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA1();
    }

    AbstractProductB createProductB() {
        return new ProductB1();
    }
}
public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA2();
    }

    AbstractProductB createProductB() {
        return new ProductB2();
    }
}
public class Client {
    public static void main(String[] args) {
        AbstractFactory abstractFactory = new ConcreteFactory1();
        AbstractProductA productA = abstractFactory.createProductA();
        AbstractProductB productB = abstractFactory.createProductB();
        // do something with productA and productB
    }
}
```

我的理解：
1. 和继承的类比。
   当我们需要根据不同的场景执行相同的方法但具体过程不同时,我们用继承来实现：父类给出各方法接口，子类实现自己的接口执行过程。
   当情况更复杂时，比如方法过于庞大臃肿，可以考虑将方法返回为类，将方法的执行过程放到具体的类里,这时，父类的方法接口就变成返回实例了。而子类将接口的功能有执行过程变成返回具体的对象，由对象去执行过程


### 生成器  ###
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。


我的理解:
1. 主要大概是说：将构建的过程，和具体的每个构建步骤完成的工作分开
2. 大概有这些类:
    * 产品类(product)
    * 生成器类(builder) 里面有 构建每个部件的具体方法 和 一个放回最终product的方法
    * 指导者类(directro)  传入一个 生成器对象，安排  部件的构建步骤
3. 举例sql生成
    * 产品类   sql语句
    * 生成器类  如何构建where  如何构建 select    如何构建limit 等(mysql有mysql的生成器，mongo有mango的生成器)  
    * 指导者   先构建select  还是先构建limit  还是说不构建limit 等;可以有多个指导者，每个指导者代表不同的构建过程,比如 先select的指导者；不带limit的指导者





### 原型模式 ###
使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。


我的理解：
1. 原型类  有一个 clone 方法，返回对象的拷贝
2. 当要得到一个新的对象时，不通过new操作，而是传入 一个已有的 对象，调用它的clone方法获得
3. 还不如叫"复制模式"
