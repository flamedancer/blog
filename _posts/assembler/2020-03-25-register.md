---
layout: post 
title: register 
categories: [assembler]
---

----
#####  -----1 内部总线  #####

1. CPU由 运算器 控制器 寄存器 等器件构成
2. 这些器件有内部总线相连
3. 内部总线：连接CPU内部器件；外部总线：连接CPU和计算机其他部件

----
#####  -----2 汇编概念 通用寄存器

1. 以8086CPU为模型，讨论寄存器及相关知识

2. AX、BX、CX、DX 为通用寄存器，都为16位

3. AX 按照高低 8 位 可分为  AH(hight),AL(low) 两个独立的寄存器用

----
#####  -----3 mov  add 指令  #####

1. MOV  传送指令：mov ax, 4E20H  (直接写入具体常数)；mov  ax,  bx (将另外寄存机的值写入本寄存器)

2. ADD 加指令：add ax, 0026H; add ax,bx

3. mov和add 指令 只能对相同位数寄存器进行操作

4. add 指令若溢出 将丢弃溢出位后写入

5. 即使是 add 造成  al 溢出，也不会 影响到 ah,  我的理解是 此时 数据线 只会用 到8位 进行数据传输，

   所以传输达到al时也是8位的数，不会对ah造成影响

----
#####  -----4 物理地址 段地址  偏移地址  #####

1. 8086CPU为16位机，即：
  
   * 运算器一次可以处理16位数据
   * 寄存器最大可以存16位数据
   * 寄存器和运算器的通路为16位
2. 虽然运算器和寄存器的通路为16位（内部总线都为16位？），但外部地址总线宽度为20
3. 如何利用外部地址线的20位宽度呢？
   * 段地址（SA） * 16 + 偏移地址(EA)
   * CPU 将  SA 和 EA 送入 **地址加法器** 输出20位物理地址
4. 段，并不是内存真的物理上被分成了段，而是逻辑概念。由CPU决定段地址，每段大小
5. 注意：
   * 由于内部总线为16位，所以偏移地址最大为  2^16
   
   * 段起始地址=SA*16   必定为 16 的倍数
   
----

#####  -----5  寄存器  CS、 IP  #####

1. CS代码段寄(code segment)存器, IP 指令指针(instruction point)寄存器

2. 8086CPU中，任意时刻，CPU从 `(CS) * 16 + (IP)`处读取指令

3. 读取一跳指令到指令缓存区后，IP自动增加(增加的值为所读指令的长度)，指向下一条指令，然后再执行。

   注意顺序：先增加IP，在执行指令

*4. 8086CPU启动后执行的第一条指令为  CS=FFFFH   （f4） IP=0000H, 即第一条指令地址 FFFF0H

#####  -----6 jmp 指令  #####

1. CS、IP不能被 mov 指令修改
2.  ` jmp 段地址：偏移地址` 同时修改  CS、IP,  eg. ` jmp  2AE3:3`
3. `jmp 偏移地址`    只修改 IP  ， eg.  ` jmp  ax`

#####  -----7. debug.exe 的使用  #####

1. r   查看 / 修改     寄存器
2. d  查看   内存
3. u  查看内存 ， 以指令方式显示
4. e  输入机器码来修改内存
5. a 输入指令来修改内存
6. debug 将可执行文件加载后，cx存放的是程序的长度

----

#####  -----7. 段寄存器  DS  (data segment)  #####

1. 8086CPU,所有段寄存器都不支持将数据直接mov进,需通过其他寄存器中转
2. 和cs类似，ds存放内存数据段的起始地址
3. 可以用  [ address ] 来 代表内存数据偏移地址
4. CPU从 `(DS) * 16 + (address)`处读取数据,eg.  `mov    ax, [0f] `将从 ds*16+0fH除取出数据写入ax



##### -----8.栈和寄存器SS,SP和指令push,pop

1. ss 栈寄存器  ，sp栈顶偏移寄存器

2. push指令内部执行步骤：

   * 根据  ss*16 + sp 找到 栈顶地址

   * sp - 2
   * 写入数据 到  ss*16 + sp
   
3. pop 指令内部执行步骤

   * 根据  ss*16 + sp 找到 栈顶地址

   * sp + 2
   * 写入数据 到 ss*16 + sp
   
4. 进行push pop 操作前，应该先设置好 ss, sp，使得  ss*16 + sp 指向栈顶
   * 所谓栈顶 为 操作前，栈中已有元素中地址最低元素的地址，操作后会改变
   * 由此可见，当栈中没有元素时，栈顶的 ss*16 + sp地址其实并不属于栈空间，而是 栈空间最高地址 + 1

5. 栈空间是由人为确定的，CPU并不知道。需要我们自己编程注意确保 栈顶 不会超出我们制定的范围

6. pop push 指令只能对 字进行操作

    

