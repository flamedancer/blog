---
layout: post 
title: loop 
categories: [assembler]
---

----
#####  -----1 寄存器bx 与[BX]  #####

1. bx存放的值可以当做一个偏移地址 EA
2. `mov ax,[bx]` 即为 ax = ((ds)*16 * (bx))
3. 只特定的寄存器比如bx可以取值当偏移地址

----
#####  -----2 loop 指令 和 寄存器 cx #####

1. 执行到 loop `s` 时  

   1. 执行 (cx)  =  (cx) -1

   2. 检查 `(cx)`是否为 0
   3. 若为0,  继续执行
   4. 否则，,跳到标号`s`处执行

2. 跳转到 `s`处的内部实现原理是：改变IP的值，使得 `(cs)*16 + ip` 指向 `s`处指令的内存地址

----
#####  -----3 安全内存空间令  #####

1. 对一段内存进行赋值时，必须保证此内存是安全合法的

2. DOS中，内存地址`0:200~0:2ff`一般来说是安全的

   

----
#####  -----4  伪指令 end  #####

1. 伪指令end    通知编译器程序结束
2. 若end后面 接了 标号，则通知编译器 程序入口为标号处（程序被加载后将`cs: ip` 指向 标号处）
----

#####  -----5  定义栈空间  #####

1. `dw` （define words）指令，定义一个字
2. `db`   (define byte)  指令，定义一个字节

3. 多个 段标记,eg:  data,  stack,  code

      ```assembly
      assume cs:code,ds:data,ss:stack
      data segment
          dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
      data ends
      
      stack segment
          dw 0,0,0,0,0,0,0,0
      stack ends
    
      code segment
      start:  mov ax,stack
              mov ss,ax
              mov sp,16
      
              mov ax,data
              mov ds,ax
      
              push ds:[0]
              push ds:[2]
              pop ds:[2]
              pop ds:[0]
      
              mov ax,4c00h
              int 21h
      
      code ends
      
      end start
      
      ```


​      

